// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Stdlib_Array = require("@rescript/runtime/lib/js/Stdlib_Array.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");

function timeToString(_t) {
  while (true) {
    let t = _t;
    switch (t.TAG) {
      case "Seconds" :
        return t._0.toString();
      case "Minutes" :
        _t = {
          TAG: "Seconds",
          _0: 60 * t._0
        };
        continue;
      case "Hours" :
        _t = {
          TAG: "Minutes",
          _0: 60 * t._0
        };
        continue;
      case "Days" :
        _t = {
          TAG: "Hours",
          _0: 24 * t._0
        };
        continue;
      case "Weeks" :
        _t = {
          TAG: "Days",
          _0: 7 * t._0
        };
        continue;
      case "Months" :
        _t = {
          TAG: "Days",
          _0: 30 * t._0
        };
        continue;
      case "Years" :
        _t = {
          TAG: "Days",
          _0: 365 * t._0
        };
        continue;
    }
  };
}

function cacheabilityToString(c) {
  return c;
}

function expirationToString(e) {
  switch (e.kind) {
    case "max-age" :
      return `max-age=` + timeToString(e._0);
    case "s-maxage" :
      return `s-maxage=` + timeToString(e._0);
    case "max-stale" :
      return `max-stale=` + timeToString(e._0);
    case "min-fresh" :
      return `min-fresh=` + timeToString(e._0);
  }
}

function revalidationToString(r) {
  if (typeof r !== "object") {
    if (r === "must-revalidate") {
      return "must-revalidate";
    } else {
      return "proxy-revalidate";
    }
  } else if (r.kind === "stale-while-revalidate") {
    return `stale-while-revalidate=` + timeToString(r._0);
  } else {
    return `stale-if-error=` + timeToString(r._0);
  }
}

function modifiersToString(m) {
  return m;
}

function extensionsToString(e) {
  if (typeof e !== "object") {
    if (e === "must-understand") {
      return "must-understand";
    } else {
      return "no-store-remote";
    }
  } else {
    return `wait-while-invalidate=` + timeToString(e._0);
  }
}

function make(noCacheOpt, cacheability, expiration, revalidation, modifiers, extensions) {
  let noCache = noCacheOpt !== undefined ? noCacheOpt : false;
  return Stdlib_Array.keepSome([
    Stdlib_Option.map(cacheability, cacheabilityToString),
    noCache ? "no-cache" : undefined,
    Stdlib_Option.map(expiration, e => e.map(expirationToString).join(", ")),
    Stdlib_Option.map(revalidation, r => r.map(revalidationToString).join(", ")),
    Stdlib_Option.map(modifiers, r => r.map(modifiersToString).join(", ")),
    Stdlib_Option.map(extensions, r => r.map(extensionsToString).join(", "))
  ]).join(", ");
}

let staticAssetsLongCache = make(undefined, "public", [{
    kind: "max-age",
    _0: {
      TAG: "Years",
      _0: 1
    }
  }], undefined, ["immutable"], undefined);

let frequentlyChangingContent = make(undefined, "public", [{
    kind: "max-age",
    _0: {
      TAG: "Minutes",
      _0: 5
    }
  }], undefined, undefined, undefined);

let sensitiveContent = make(undefined, "private", [{
    kind: "max-age",
    _0: {
      TAG: "Seconds",
      _0: 0
    }
  }], ["must-revalidate"], undefined, undefined);

let alwaysValidate = make(undefined, "public", [{
    kind: "max-age",
    _0: {
      TAG: "Minutes",
      _0: 1
    }
  }], ["must-revalidate"], undefined, undefined);

let neverCache = make(true, "no-store", undefined, undefined, undefined, undefined);

let Presets = {
  staticAssetsLongCache: staticAssetsLongCache,
  frequentlyChangingContent: frequentlyChangingContent,
  sensitiveContent: sensitiveContent,
  alwaysValidate: alwaysValidate,
  neverCache: neverCache
};

let CacheControl = {
  timeToString: timeToString,
  cacheabilityToString: cacheabilityToString,
  expirationToString: expirationToString,
  revalidationToString: revalidationToString,
  modifiersToString: modifiersToString,
  extensionsToString: extensionsToString,
  make: make,
  Presets: Presets
};

exports.CacheControl = CacheControl;
/* staticAssetsLongCache Not a pure module */
