// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let H$ResX = require("./H.js");
let CSRF$ResX = require("./CSRF.js");
let Stdlib_List = require("@rescript/runtime/lib/js/Stdlib_List.js");
let Stdlib_Array = require("@rescript/runtime/lib/js/Stdlib_Array.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");
let Primitive_option = require("@rescript/runtime/lib/js/Primitive_option.js");
let Nodeasync_hooks = require("node:async_hooks");
let HyperonsJs = require("./vendor/hyperons.js");
let RequestController$ResX = require("./RequestController.js");

function string(s) {
  return s;
}

function toEndpointURL(s) {
  return s;
}

let FormAction = {
  string: string,
  toEndpointURL: toEndpointURL
};

function make(requestToContext, options) {
  return {
    htmxHandlers: [],
    formActionHandlers: [],
    requestToContext: requestToContext,
    asyncLocalStorage: new Nodeasync_hooks.AsyncLocalStorage(),
    htmxApiPrefix: Stdlib_Option.getOr(Stdlib_Option.flatMap(options, options => options.htmxApiPrefix), "/_api"),
    formActionHandlerApiPrefix: Stdlib_Option.getOr(Stdlib_Option.flatMap(options, options => options.formActionHandlerApiPrefix), "/_form"),
    defaultCsrfCheck: Stdlib_Option.getOr(Stdlib_Option.flatMap(options, options => options.defaultCsrfCheck), {
      TAG: "ForAllMethods",
      _0: false
    })
  };
}

function isCsrfEnabledFor(t, m) {
  let v = t.defaultCsrfCheck;
  if (v.TAG === "ForAllMethods") {
    return v._0;
  }
  switch (m) {
    case "GET" :
      return Stdlib_Option.getOr(v.get, false);
    case "POST" :
      return Stdlib_Option.getOr(v.post, false);
    case "PUT" :
      return Stdlib_Option.getOr(v.put, false);
    case "DELETE" :
      return Stdlib_Option.getOr(v.delete, false);
    case "PATCH" :
      return Stdlib_Option.getOr(v.patch, false);
    default:
      return false;
  }
}

function useContext(t) {
  return t.asyncLocalStorage.getStore();
}

function defaultRenderTitle(segments) {
  return segments.join(" | ");
}

async function renderWithDocType(el, requestController, renderTitleOpt, onAfterRenderOpt) {
  let renderTitle = renderTitleOpt !== undefined ? renderTitleOpt : defaultRenderTitle;
  let onAfterRender = onAfterRenderOpt !== undefined ? onAfterRenderOpt : async () => {};
  let content = await H$ResX.renderToString(el);
  await onAfterRender();
  let appendToHead = await RequestController$ResX.getAppendedHeadContent(requestController);
  let appendBeforeBodyEnd = await RequestController$ResX.getAppendedBeforeBodyEndContent(requestController);
  let match = RequestController$ResX.getTitleSegments(requestController);
  let appendToHead$1;
  if (match.length !== 0) {
    if (appendToHead !== undefined) {
      let titleElement = `<title>` + HyperonsJs.escapeString(renderTitle(match)) + `</title>`;
      appendToHead$1 = appendToHead + titleElement;
    } else {
      appendToHead$1 = `<title>` + HyperonsJs.escapeString(renderTitle(match)) + `</title>`;
    }
  } else {
    appendToHead$1 = appendToHead;
  }
  let content$1 = appendToHead$1 !== undefined ? content.replace("</head>", appendToHead$1 + "</head>") : content;
  let content$2 = appendBeforeBodyEnd !== undefined ? content$1.replace("</body>", appendBeforeBodyEnd + "</body>") : content$1;
  return RequestController$ResX.getDocHeader(requestController) + content$2;
}

let defaultHeaders = [[
    "Content-Type",
    "text/html"
  ]];

async function handleRequest(t, config) {
  let onAfterBuildResponse = config.onAfterBuildResponse;
  let onBeforeBuildResponse = config.onBeforeBuildResponse;
  let onBeforeSendResponse = config.onBeforeSendResponse;
  let render = config.render;
  let request = config.request;
  let stream = Stdlib_Option.getOr(config.experimental_stream, false);
  let url = new URL(request.url);
  let pathname = url.pathname;
  let targetFormActionHandler = Stdlib_Array.findMap(t.formActionHandlers, reg => {
    let match = request.method;
    switch (match) {
      case "GET" :
      case "POST" :
        break;
      default:
        return;
    }
    if (reg.path === pathname) {
      return reg;
    }
  });
  let targetHtmxHandler = Stdlib_Array.findMap(t.htmxHandlers, reg => {
    if (reg.method === request.method && reg.path === pathname) {
      return reg;
    }
  });
  let ctx = await t.requestToContext(request);
  let requestController = RequestController$ResX.make();
  let setupHeaders = config.setupHeaders;
  let headers = setupHeaders !== undefined ? setupHeaders() : new Headers(defaultHeaders);
  let renderConfig_path = Stdlib_List.fromArray(pathname.split("/").filter(s => s.trim() !== ""));
  let renderConfig = {
    request: request,
    headers: headers,
    context: ctx,
    path: renderConfig_path,
    url: url,
    requestController: requestController
  };
  return await t.asyncLocalStorage.run(renderConfig, async _token => {
    let isFormAction = Stdlib_Option.isSome(targetFormActionHandler);
    let content;
    if (targetFormActionHandler !== undefined) {
      content = null;
    } else if (targetHtmxHandler !== undefined) {
      let csrfEnabled = Stdlib_Option.getOr(targetHtmxHandler.csrfCheckOpt, isCsrfEnabledFor(t, targetHtmxHandler.method));
      let csrfOk = csrfEnabled ? await CSRF$ResX.verifyRequest(request) : true;
      if (csrfOk) {
        let securityPolicy = await targetHtmxHandler.securityPolicyHandler({
          request: request,
          context: ctx
        });
        if (typeof securityPolicy !== "object") {
          content = await targetHtmxHandler.handler({
            request: request,
            context: ctx,
            headers: headers,
            requestController: requestController
          });
        } else {
          RequestController$ResX.setStatus(requestController, Stdlib_Option.getOr(securityPolicy.code, 403));
          content = Stdlib_Option.getOr(securityPolicy.message, "Not Allowed.");
        }
      } else {
        RequestController$ResX.setStatus(requestController, 403);
        content = "Invalid CSRF token.";
      }
    } else {
      content = await render(renderConfig);
    }
    let responseType = targetFormActionHandler !== undefined ? "FormActionHandler" : (
        targetHtmxHandler !== undefined ? "HtmxHandler" : "Default"
      );
    if (onBeforeBuildResponse !== undefined) {
      await onBeforeBuildResponse({
        request: request,
        context: ctx,
        responseType: responseType,
        requestController: requestController
      });
    }
    if (isFormAction) {
      let reg = Stdlib_Option.getOrThrow(targetFormActionHandler, undefined);
      let csrfEnabled$1 = Stdlib_Option.getOr(reg.csrfCheckOpt, isCsrfEnabledFor(t, request.method));
      let csrfOk$1 = csrfEnabled$1 ? await CSRF$ResX.verifyRequest(request) : true;
      let response;
      if (csrfOk$1) {
        let match = await reg.securityPolicyHandler({
          request: request,
          context: ctx
        });
        response = typeof match !== "object" ? await reg.handler({
            request: request,
            context: ctx
          }) : new Response(Stdlib_Option.getOr(match.message, "Not Allowed."), {
            status: Stdlib_Option.getOr(match.code, 403)
          });
      } else {
        response = new Response("Invalid CSRF token.", {
          status: 403
        });
      }
      if (onBeforeSendResponse !== undefined) {
        return await onBeforeSendResponse({
          request: request,
          response: response,
          context: ctx,
          responseType: responseType
        });
      } else {
        return response;
      }
    }
    if (stream) {
      let match$1 = new TransformStream({
        transform: (chunk, controller) => {
          controller.enqueue(chunk);
        }
      });
      let writer = match$1.writable.getWriter();
      let textEncoder = new TextEncoder();
      H$ResX.renderToStream(content, chunk => {
        let encoded = textEncoder.encode(chunk);
        writer.write(encoded);
      }).then(() => writer.close());
      let response$1 = new Response(match$1.readable, {
        status: 200,
        headers: [[
            "Content-Type",
            "text/html"
          ]]
      });
      if (onBeforeSendResponse !== undefined) {
        return await onBeforeSendResponse({
          request: request,
          response: response$1,
          context: ctx,
          responseType: responseType
        });
      } else {
        return response$1;
      }
    }
    let onAfterRender = onAfterBuildResponse !== undefined ? async () => await onAfterBuildResponse({
        request: request,
        context: ctx,
        responseType: responseType,
        requestController: requestController
      }) : undefined;
    let content$1 = await renderWithDocType(content, requestController, config.renderTitle, onAfterRender);
    let match$2 = RequestController$ResX.getCurrentRedirect(requestController);
    let match$3 = RequestController$ResX.getCurrentStatus(requestController);
    let response$2 = match$2 !== undefined ? Response.redirect(match$2[0], Primitive_option.toUndefined(match$2[1])) : new Response(content$1, {
        status: match$3,
        headers: Primitive_option.some(headers)
      });
    if (onBeforeSendResponse !== undefined) {
      return await onBeforeSendResponse({
        request: request,
        response: response$2,
        context: ctx,
        responseType: responseType
      });
    } else {
      return response$2;
    }
  });
}

function formAction(t, path, securityPolicy, handler, csrfCheck) {
  let path$1 = t.formActionHandlerApiPrefix + path;
  t.formActionHandlers.push({
    path: path$1,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
  return path$1;
}

function hxGet(t, path, securityPolicy, handler, csrfCheck) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push({
    method: "GET",
    path: path$1,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
  return path$1;
}

function hxGetRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxGetDefine(t, path, securityPolicy, handler, csrfCheck) {
  t.htmxHandlers.push({
    method: "GET",
    path: path,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
}

function hxGetToEndpointURL(s) {
  return s;
}

function hxPost(t, path, securityPolicy, handler, csrfCheck) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push({
    method: "POST",
    path: path$1,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
  return path$1;
}

function hxPostRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxPostDefine(t, path, securityPolicy, handler, csrfCheck) {
  t.htmxHandlers.push({
    method: "POST",
    path: path,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
}

function hxPostToEndpointURL(s) {
  return s;
}

function hxPut(t, path, securityPolicy, handler, csrfCheck) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push({
    method: "PUT",
    path: path$1,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
  return path$1;
}

function hxPutRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxPutDefine(t, path, securityPolicy, handler, csrfCheck) {
  t.htmxHandlers.push({
    method: "PUT",
    path: path,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
}

function hxPutToEndpointURL(s) {
  return s;
}

function hxDelete(t, path, securityPolicy, handler, csrfCheck) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push({
    method: "DELETE",
    path: path$1,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
  return path$1;
}

function hxDeleteRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxDeleteDefine(t, path, securityPolicy, handler, csrfCheck) {
  t.htmxHandlers.push({
    method: "DELETE",
    path: path,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
}

function hxDeleteToEndpointURL(s) {
  return s;
}

function hxPatch(t, path, securityPolicy, handler, csrfCheck) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push({
    method: "PATCH",
    path: path$1,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
  return path$1;
}

function hxPatchRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxPatchDefine(t, path, securityPolicy, handler, csrfCheck) {
  t.htmxHandlers.push({
    method: "PATCH",
    path: path,
    securityPolicyHandler: securityPolicy,
    csrfCheckOpt: csrfCheck,
    handler: handler
  });
}

function hxPatchToEndpointURL(s) {
  return s;
}

function getHandlers(t) {
  return t.htmxHandlers;
}

let Internal = {
  getHandlers: getHandlers
};

exports.FormAction = FormAction;
exports.make = make;
exports.formAction = formAction;
exports.hxGet = hxGet;
exports.hxGetRef = hxGetRef;
exports.hxGetDefine = hxGetDefine;
exports.hxGetToEndpointURL = hxGetToEndpointURL;
exports.hxPost = hxPost;
exports.hxPostRef = hxPostRef;
exports.hxPostDefine = hxPostDefine;
exports.hxPostToEndpointURL = hxPostToEndpointURL;
exports.hxPut = hxPut;
exports.hxPutRef = hxPutRef;
exports.hxPutDefine = hxPutDefine;
exports.hxPutToEndpointURL = hxPutToEndpointURL;
exports.hxDelete = hxDelete;
exports.hxDeleteRef = hxDeleteRef;
exports.hxDeleteDefine = hxDeleteDefine;
exports.hxDeleteToEndpointURL = hxDeleteToEndpointURL;
exports.hxPatch = hxPatch;
exports.hxPatchRef = hxPatchRef;
exports.hxPatchDefine = hxPatchDefine;
exports.hxPatchToEndpointURL = hxPatchToEndpointURL;
exports.useContext = useContext;
exports.handleRequest = handleRequest;
exports.Internal = Internal;
/* H-ResX Not a pure module */
