// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var H$ResX = require("./H.js");
var Core__List = require("@rescript/core/src/Core__List.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/src/Core__Array.js");
var Core__Option = require("@rescript/core/src/Core__Option.js");
var Nodeasync_hooks = require("node:async_hooks");
var HyperonsJs = require("./vendor/hyperons.js");
var RequestController$ResX = require("./RequestController.js");

function string(s) {
  return s;
}

var FormAction = {
  string: string
};

function make(requestToContext, options) {
  return {
          htmxHandlers: [],
          formActionHandlers: [],
          requestToContext: requestToContext,
          asyncLocalStorage: new Nodeasync_hooks.AsyncLocalStorage(),
          htmxApiPrefix: Core__Option.getOr(Core__Option.flatMap(options, (function (options) {
                      return options.htmxApiPrefix;
                    })), "/_api"),
          formActionHandlerApiPrefix: Core__Option.getOr(Core__Option.flatMap(options, (function (options) {
                      return options.formActionHandlerApiPrefix;
                    })), "/_form")
        };
}

function useContext(t) {
  return t.asyncLocalStorage.getStore();
}

function defaultRenderTitle(segments) {
  return segments.join(" | ");
}

async function renderWithDocType(el, requestController, renderTitleOpt) {
  var renderTitle = renderTitleOpt !== undefined ? renderTitleOpt : defaultRenderTitle;
  var content = await H$ResX.renderToString(el);
  var appendToHead = await RequestController$ResX.getAppendedHeadContent(requestController);
  var match = RequestController$ResX.getTitleSegments(requestController);
  var appendToHead$1;
  if (match.length !== 0) {
    if (appendToHead !== undefined) {
      var titleElement = "<title>" + HyperonsJs.escapeString(renderTitle(match)) + "</title>";
      appendToHead$1 = appendToHead + titleElement;
    } else {
      appendToHead$1 = "<title>" + HyperonsJs.escapeString(renderTitle(match)) + "</title>";
    }
  } else {
    appendToHead$1 = appendToHead;
  }
  var content$1 = appendToHead$1 !== undefined ? content.replace("</head>", appendToHead$1 + "</head>") : content;
  return RequestController$ResX.getDocHeader(requestController) + content$1;
}

var defaultHeaders = [[
    "Content-Type",
    "text/html"
  ]];

async function handleRequest(t, config) {
  var onBeforeBuildResponse = config.onBeforeBuildResponse;
  var onBeforeSendResponse = config.onBeforeSendResponse;
  var render = config.render;
  var request = config.request;
  var stream = Core__Option.getOr(config.experimental_stream, false);
  var url = new URL(request.url);
  var pathname = url.pathname;
  var targetFormActionHandler = Core__Array.findMap(t.formActionHandlers, (function (param) {
          var match = request.method;
          switch (match) {
            case "GET" :
            case "POST" :
                break;
            default:
              return ;
          }
          if (param[0] === pathname) {
            return [
                    param[1],
                    param[2]
                  ];
          }
          
        }));
  var targetHtmxHandler = Core__Array.findMap(t.htmxHandlers, (function (param) {
          if (param[0] === request.method && param[1] === pathname) {
            return [
                    param[2],
                    param[3]
                  ];
          }
          
        }));
  var ctx = await t.requestToContext(request);
  var requestController = RequestController$ResX.make();
  var setupHeaders = config.setupHeaders;
  var headers = setupHeaders !== undefined ? setupHeaders() : new Headers(defaultHeaders);
  var renderConfig_path = Core__List.fromArray(pathname.split("/").filter(function (s) {
            return s.trim() !== "";
          }));
  var renderConfig = {
    request: request,
    headers: headers,
    context: ctx,
    path: renderConfig_path,
    url: url,
    requestController: requestController
  };
  return await t.asyncLocalStorage.run(renderConfig, (async function (_token) {
                var isFormAction = Core__Option.isSome(targetFormActionHandler);
                var content;
                if (targetFormActionHandler !== undefined) {
                  content = null;
                } else if (targetHtmxHandler !== undefined) {
                  var securityPolicy = await targetHtmxHandler[0]({
                        request: request,
                        context: ctx
                      });
                  if (typeof securityPolicy !== "object") {
                    content = await targetHtmxHandler[1]({
                          request: request,
                          context: ctx,
                          headers: headers,
                          requestController: requestController
                        });
                  } else {
                    RequestController$ResX.setStatus(requestController, Core__Option.getOr(securityPolicy.code, 403));
                    content = Core__Option.getOr(securityPolicy.message, "Not Allowed.");
                  }
                } else {
                  content = await render(renderConfig);
                }
                var responseType = targetFormActionHandler !== undefined ? "FormActionHandler" : (
                    targetHtmxHandler !== undefined ? "HtmxHandler" : "Default"
                  );
                if (onBeforeBuildResponse !== undefined) {
                  await onBeforeBuildResponse({
                        request: request,
                        context: ctx,
                        responseType: responseType
                      });
                }
                if (isFormAction) {
                  var match = Core__Option.getExn(targetFormActionHandler, undefined);
                  var match$1 = await match[0]({
                        request: request,
                        context: ctx
                      });
                  var response;
                  response = typeof match$1 !== "object" ? await match[1]({
                          request: request,
                          context: ctx
                        }) : new Response(Core__Option.getOr(match$1.message, "Not Allowed."), {
                          status: Core__Option.getOr(match$1.code, 403)
                        });
                  if (onBeforeSendResponse !== undefined) {
                    return await onBeforeSendResponse({
                                request: request,
                                response: response,
                                context: ctx,
                                responseType: responseType
                              });
                  } else {
                    return response;
                  }
                }
                if (stream) {
                  var match$2 = new TransformStream({
                        transform: (function (chunk, controller) {
                            controller.enqueue(chunk);
                          })
                      });
                  var writer = match$2.writable.getWriter();
                  var textEncoder = new TextEncoder();
                  H$ResX.renderToStream(content, (function (chunk) {
                            var encoded = textEncoder.encode(chunk);
                            writer.write(encoded);
                          })).then(function () {
                        return writer.close();
                      });
                  var response$1 = new Response(match$2.readable, {
                        status: 200,
                        headers: [[
                            "Content-Type",
                            "text/html"
                          ]]
                      });
                  if (onBeforeSendResponse !== undefined) {
                    return await onBeforeSendResponse({
                                request: request,
                                response: response$1,
                                context: ctx,
                                responseType: responseType
                              });
                  } else {
                    return response$1;
                  }
                }
                var content$1 = await renderWithDocType(content, requestController, config.renderTitle);
                var match$3 = RequestController$ResX.getCurrentRedirect(requestController);
                var match$4 = RequestController$ResX.getCurrentStatus(requestController);
                var response$2 = match$3 !== undefined ? Response.redirect(match$3[0], Caml_option.option_get(match$3[1])) : new Response(content$1, {
                        status: match$4,
                        headers: Caml_option.some(headers)
                      });
                if (onBeforeSendResponse !== undefined) {
                  return await onBeforeSendResponse({
                              request: request,
                              response: response$2,
                              context: ctx,
                              responseType: responseType
                            });
                } else {
                  return response$2;
                }
              }));
}

function formAction(t, path, securityPolicy, handler) {
  var path$1 = t.formActionHandlerApiPrefix + path;
  t.formActionHandlers.push([
        path$1,
        securityPolicy,
        handler
      ]);
  return path$1;
}

function hxGet(t, path, securityPolicy, handler) {
  var path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
        "GET",
        path$1,
        securityPolicy,
        handler
      ]);
  return path$1;
}

function makeHxGetIdentifier(t, path) {
  return t.htmxApiPrefix + path;
}

function implementHxGetIdentifier(t, path, securityPolicy, handler) {
  hxGet(t, path, securityPolicy, handler);
}

function hxPost(t, path, securityPolicy, handler) {
  var path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
        "POST",
        path$1,
        securityPolicy,
        handler
      ]);
  return path$1;
}

function makeHxPostIdentifier(t, path) {
  return t.htmxApiPrefix + path;
}

function implementHxPostIdentifier(t, path, securityPolicy, handler) {
  hxPost(t, path, securityPolicy, handler);
}

function hxPut(t, path, securityPolicy, handler) {
  var path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
        "PUT",
        path$1,
        securityPolicy,
        handler
      ]);
  return path$1;
}

function makeHxPutIdentifier(t, path) {
  return t.htmxApiPrefix + path;
}

function implementHxPutIdentifier(t, path, securityPolicy, handler) {
  hxPut(t, path, securityPolicy, handler);
}

function hxDelete(t, path, securityPolicy, handler) {
  var path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
        "DELETE",
        path$1,
        securityPolicy,
        handler
      ]);
  return path$1;
}

function makeHxDeleteIdentifier(t, path) {
  return t.htmxApiPrefix + path;
}

function implementHxDeleteIdentifier(t, path, securityPolicy, handler) {
  hxDelete(t, path, securityPolicy, handler);
}

function hxPatch(t, path, securityPolicy, handler) {
  var path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
        "PATCH",
        path$1,
        securityPolicy,
        handler
      ]);
  return path$1;
}

function makeHxPatchIdentifier(t, path) {
  return t.htmxApiPrefix + path;
}

function implementHxPatchIdentifier(t, path, securityPolicy, handler) {
  hxPatch(t, path, securityPolicy, handler);
}

function getHandlers(t) {
  return t.htmxHandlers;
}

var Internal = {
  getHandlers: getHandlers
};

exports.FormAction = FormAction;
exports.make = make;
exports.formAction = formAction;
exports.hxGet = hxGet;
exports.makeHxGetIdentifier = makeHxGetIdentifier;
exports.implementHxGetIdentifier = implementHxGetIdentifier;
exports.hxPost = hxPost;
exports.makeHxPostIdentifier = makeHxPostIdentifier;
exports.implementHxPostIdentifier = implementHxPostIdentifier;
exports.hxPut = hxPut;
exports.makeHxPutIdentifier = makeHxPutIdentifier;
exports.implementHxPutIdentifier = implementHxPutIdentifier;
exports.hxDelete = hxDelete;
exports.makeHxDeleteIdentifier = makeHxDeleteIdentifier;
exports.implementHxDeleteIdentifier = implementHxDeleteIdentifier;
exports.hxPatch = hxPatch;
exports.makeHxPatchIdentifier = makeHxPatchIdentifier;
exports.implementHxPatchIdentifier = implementHxPatchIdentifier;
exports.useContext = useContext;
exports.handleRequest = handleRequest;
exports.Internal = Internal;
/* H-ResX Not a pure module */
