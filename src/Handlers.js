// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let H$ResX = require("./H.js");
let Stdlib_List = require("@rescript/runtime/lib/js/Stdlib_List.js");
let Stdlib_Array = require("@rescript/runtime/lib/js/Stdlib_Array.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");
let Primitive_option = require("@rescript/runtime/lib/js/Primitive_option.js");
let Nodeasync_hooks = require("node:async_hooks");
let HyperonsJs = require("./vendor/hyperons.js");
let RequestController$ResX = require("./RequestController.js");

function string(s) {
  return s;
}

function toEndpointURL(s) {
  return s;
}

let FormAction = {
  string: string,
  toEndpointURL: toEndpointURL
};

function make(requestToContext, options) {
  return {
    htmxHandlers: [],
    formActionHandlers: [],
    requestToContext: requestToContext,
    asyncLocalStorage: new Nodeasync_hooks.AsyncLocalStorage(),
    htmxApiPrefix: Stdlib_Option.getOr(Stdlib_Option.flatMap(options, options => options.htmxApiPrefix), "/_api"),
    formActionHandlerApiPrefix: Stdlib_Option.getOr(Stdlib_Option.flatMap(options, options => options.formActionHandlerApiPrefix), "/_form")
  };
}

function useContext(t) {
  return t.asyncLocalStorage.getStore();
}

function defaultRenderTitle(segments) {
  return segments.join(" | ");
}

async function renderWithDocType(el, requestController, renderTitleOpt, onAfterRenderOpt) {
  let renderTitle = renderTitleOpt !== undefined ? renderTitleOpt : defaultRenderTitle;
  let onAfterRender = onAfterRenderOpt !== undefined ? onAfterRenderOpt : async () => {};
  let content = await H$ResX.renderToString(el);
  await onAfterRender();
  let appendToHead = await RequestController$ResX.getAppendedHeadContent(requestController);
  let appendBeforeBodyEnd = await RequestController$ResX.getAppendedBeforeBodyEndContent(requestController);
  let match = RequestController$ResX.getTitleSegments(requestController);
  let appendToHead$1;
  if (match.length !== 0) {
    if (appendToHead !== undefined) {
      let titleElement = `<title>` + HyperonsJs.escapeString(renderTitle(match)) + `</title>`;
      appendToHead$1 = appendToHead + titleElement;
    } else {
      appendToHead$1 = `<title>` + HyperonsJs.escapeString(renderTitle(match)) + `</title>`;
    }
  } else {
    appendToHead$1 = appendToHead;
  }
  let content$1 = appendToHead$1 !== undefined ? content.replace("</head>", appendToHead$1 + "</head>") : content;
  let content$2 = appendBeforeBodyEnd !== undefined ? content$1.replace("</body>", appendBeforeBodyEnd + "</body>") : content$1;
  return RequestController$ResX.getDocHeader(requestController) + content$2;
}

let defaultHeaders = [[
    "Content-Type",
    "text/html"
  ]];

async function handleRequest(t, config) {
  let onAfterBuildResponse = config.onAfterBuildResponse;
  let onBeforeBuildResponse = config.onBeforeBuildResponse;
  let onBeforeSendResponse = config.onBeforeSendResponse;
  let render = config.render;
  let request = config.request;
  let stream = Stdlib_Option.getOr(config.experimental_stream, false);
  let url = new URL(request.url);
  let pathname = url.pathname;
  let targetFormActionHandler = Stdlib_Array.findMap(t.formActionHandlers, param => {
    let match = request.method;
    switch (match) {
      case "GET" :
      case "POST" :
        break;
      default:
        return;
    }
    if (param[0] === pathname) {
      return [
        param[1],
        param[2]
      ];
    }
  });
  let targetHtmxHandler = Stdlib_Array.findMap(t.htmxHandlers, param => {
    if (param[0] === request.method && param[1] === pathname) {
      return [
        param[2],
        param[3]
      ];
    }
  });
  let ctx = await t.requestToContext(request);
  let requestController = RequestController$ResX.make();
  let setupHeaders = config.setupHeaders;
  let headers = setupHeaders !== undefined ? setupHeaders() : new Headers(defaultHeaders);
  let renderConfig_path = Stdlib_List.fromArray(pathname.split("/").filter(s => s.trim() !== ""));
  let renderConfig = {
    request: request,
    headers: headers,
    context: ctx,
    path: renderConfig_path,
    url: url,
    requestController: requestController
  };
  return await t.asyncLocalStorage.run(renderConfig, async _token => {
    let isFormAction = Stdlib_Option.isSome(targetFormActionHandler);
    let content;
    if (targetFormActionHandler !== undefined) {
      content = null;
    } else if (targetHtmxHandler !== undefined) {
      let securityPolicy = await targetHtmxHandler[0]({
        request: request,
        context: ctx
      });
      if (typeof securityPolicy !== "object") {
        content = await targetHtmxHandler[1]({
          request: request,
          context: ctx,
          headers: headers,
          requestController: requestController
        });
      } else {
        RequestController$ResX.setStatus(requestController, Stdlib_Option.getOr(securityPolicy.code, 403));
        content = Stdlib_Option.getOr(securityPolicy.message, "Not Allowed.");
      }
    } else {
      content = await render(renderConfig);
    }
    let responseType = targetFormActionHandler !== undefined ? "FormActionHandler" : (
        targetHtmxHandler !== undefined ? "HtmxHandler" : "Default"
      );
    if (onBeforeBuildResponse !== undefined) {
      await onBeforeBuildResponse({
        request: request,
        context: ctx,
        responseType: responseType,
        requestController: requestController
      });
    }
    if (isFormAction) {
      let match = Stdlib_Option.getOrThrow(targetFormActionHandler, undefined);
      let match$1 = await match[0]({
        request: request,
        context: ctx
      });
      let response;
      response = typeof match$1 !== "object" ? await match[1]({
          request: request,
          context: ctx
        }) : new Response(Stdlib_Option.getOr(match$1.message, "Not Allowed."), {
          status: Stdlib_Option.getOr(match$1.code, 403)
        });
      if (onBeforeSendResponse !== undefined) {
        return await onBeforeSendResponse({
          request: request,
          response: response,
          context: ctx,
          responseType: responseType
        });
      } else {
        return response;
      }
    }
    if (stream) {
      let match$2 = new TransformStream({
        transform: (chunk, controller) => {
          controller.enqueue(chunk);
        }
      });
      let writer = match$2.writable.getWriter();
      let textEncoder = new TextEncoder();
      H$ResX.renderToStream(content, chunk => {
        let encoded = textEncoder.encode(chunk);
        writer.write(encoded);
      }).then(() => writer.close());
      let response$1 = new Response(match$2.readable, {
        status: 200,
        headers: [[
            "Content-Type",
            "text/html"
          ]]
      });
      if (onBeforeSendResponse !== undefined) {
        return await onBeforeSendResponse({
          request: request,
          response: response$1,
          context: ctx,
          responseType: responseType
        });
      } else {
        return response$1;
      }
    }
    let onAfterRender = onAfterBuildResponse !== undefined ? async () => await onAfterBuildResponse({
        request: request,
        context: ctx,
        responseType: responseType,
        requestController: requestController
      }) : undefined;
    let content$1 = await renderWithDocType(content, requestController, config.renderTitle, onAfterRender);
    let match$3 = RequestController$ResX.getCurrentRedirect(requestController);
    let match$4 = RequestController$ResX.getCurrentStatus(requestController);
    let response$2 = match$3 !== undefined ? Response.redirect(match$3[0], Primitive_option.toUndefined(match$3[1])) : new Response(content$1, {
        status: match$4,
        headers: Primitive_option.some(headers)
      });
    if (onBeforeSendResponse !== undefined) {
      return await onBeforeSendResponse({
        request: request,
        response: response$2,
        context: ctx,
        responseType: responseType
      });
    } else {
      return response$2;
    }
  });
}

function formAction(t, path, securityPolicy, handler) {
  let path$1 = t.formActionHandlerApiPrefix + path;
  t.formActionHandlers.push([
    path$1,
    securityPolicy,
    handler
  ]);
  return path$1;
}

function hxGet(t, path, securityPolicy, handler) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
    "GET",
    path$1,
    securityPolicy,
    handler
  ]);
  return path$1;
}

function hxGetRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxGetDefine(t, path, securityPolicy, handler) {
  t.htmxHandlers.push([
    "GET",
    path,
    securityPolicy,
    handler
  ]);
}

function hxGetToEndpointURL(s) {
  return s;
}

function hxPost(t, path, securityPolicy, handler) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
    "POST",
    path$1,
    securityPolicy,
    handler
  ]);
  return path$1;
}

function hxPostRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxPostDefine(t, path, securityPolicy, handler) {
  t.htmxHandlers.push([
    "POST",
    path,
    securityPolicy,
    handler
  ]);
}

function hxPostToEndpointURL(s) {
  return s;
}

function hxPut(t, path, securityPolicy, handler) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
    "PUT",
    path$1,
    securityPolicy,
    handler
  ]);
  return path$1;
}

function hxPutRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxPutDefine(t, path, securityPolicy, handler) {
  t.htmxHandlers.push([
    "PUT",
    path,
    securityPolicy,
    handler
  ]);
}

function hxPutToEndpointURL(s) {
  return s;
}

function hxDelete(t, path, securityPolicy, handler) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
    "DELETE",
    path$1,
    securityPolicy,
    handler
  ]);
  return path$1;
}

function hxDeleteRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxDeleteDefine(t, path, securityPolicy, handler) {
  t.htmxHandlers.push([
    "DELETE",
    path,
    securityPolicy,
    handler
  ]);
}

function hxDeleteToEndpointURL(s) {
  return s;
}

function hxPatch(t, path, securityPolicy, handler) {
  let path$1 = t.htmxApiPrefix + path;
  t.htmxHandlers.push([
    "PATCH",
    path$1,
    securityPolicy,
    handler
  ]);
  return path$1;
}

function hxPatchRef(t, path) {
  return t.htmxApiPrefix + path;
}

function hxPatchDefine(t, path, securityPolicy, handler) {
  t.htmxHandlers.push([
    "PATCH",
    path,
    securityPolicy,
    handler
  ]);
}

function hxPatchToEndpointURL(s) {
  return s;
}

function getHandlers(t) {
  return t.htmxHandlers;
}

let Internal = {
  getHandlers: getHandlers
};

exports.FormAction = FormAction;
exports.make = make;
exports.formAction = formAction;
exports.hxGet = hxGet;
exports.hxGetRef = hxGetRef;
exports.hxGetDefine = hxGetDefine;
exports.hxGetToEndpointURL = hxGetToEndpointURL;
exports.hxPost = hxPost;
exports.hxPostRef = hxPostRef;
exports.hxPostDefine = hxPostDefine;
exports.hxPostToEndpointURL = hxPostToEndpointURL;
exports.hxPut = hxPut;
exports.hxPutRef = hxPutRef;
exports.hxPutDefine = hxPutDefine;
exports.hxPutToEndpointURL = hxPutToEndpointURL;
exports.hxDelete = hxDelete;
exports.hxDeleteRef = hxDeleteRef;
exports.hxDeleteDefine = hxDeleteDefine;
exports.hxDeleteToEndpointURL = hxDeleteToEndpointURL;
exports.hxPatch = hxPatch;
exports.hxPatchRef = hxPatchRef;
exports.hxPatchDefine = hxPatchDefine;
exports.hxPatchToEndpointURL = hxPatchToEndpointURL;
exports.useContext = useContext;
exports.handleRequest = handleRequest;
exports.Internal = Internal;
/* H-ResX Not a pure module */
