// Generated by ReScript, PLEASE EDIT WITH CARE

let Stdlib_Array = require("@rescript/runtime/lib/js/Stdlib_Array.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");

function make(swap, modifier) {
  return Stdlib_Array.keepSome([
    swap,
    Stdlib_Option.map(modifier, modifier => {
      if (typeof modifier !== "object") {
        return `transition:true`;
      }
      switch (modifier.TAG) {
        case "Swap" :
          return `swap:` + modifier._0;
        case "Settle" :
          return `settle:` + modifier._0;
        case "Scroll" :
          return `scroll:` + modifier._0;
        case "ScrollWithSelector" :
          return `scroll:` + modifier._0 + `:` + modifier._1;
        case "Show" :
          return `show:` + modifier._0;
        case "ShowWithSelector" :
          return `show:` + modifier._0 + `:` + modifier._1;
      }
    })
  ]).join(" ");
}

let Swap = {
  make: make
};

function make$1(target) {
  if (typeof target !== "object") {
    return "this";
  }
  switch (target.TAG) {
    case "CssSelector" :
      return target._0;
    case "Closest" :
      return `closest ` + target.cssSelector;
    case "Find" :
      return `find ` + target.cssSelector;
    case "Next" :
      return `next ` + target.cssSelector;
    case "Previous" :
      return `previous ` + target.cssSelector;
  }
}

let Target = {
  make: make$1
};

function make$2(p) {
  if (typeof p !== "object") {
    if (p === "IncludeAll") {
      return "*";
    } else {
      return "none";
    }
  } else if (p.TAG === "Not") {
    return `not ` + p._0.join(",");
  } else {
    return p._0.join(",");
  }
}

let Params = {
  make: make$2
};

function make$3(encoding) {
  return "multipart/form-data";
}

let Encoding = {
  make: make$3
};

function make$4(hxIndicator) {
  if (hxIndicator.TAG === "Selector") {
    return hxIndicator._0;
  } else {
    return `closest ` + hxIndicator._0;
  }
}

let Indicator = {
  make: make$4
};

function make$5(dict) {
  return Stdlib_Option.getOr(JSON.stringify(dict), "{}");
}

let Headers = {
  make: make$5
};

function strategyToString(s) {
  if (typeof s !== "object") {
    switch (s) {
      case "Drop" :
        return "drop";
      case "Abort" :
        return "abort";
      case "Replace" :
        return "replace";
      case "Queue" :
        return "queue";
    }
  } else {
    let tmp;
    switch (s._0) {
      case "first" :
        tmp = "first";
        break;
      case "last" :
        tmp = "last";
        break;
      case "all" :
        tmp = "all";
        break;
    }
    return `queue ` + tmp;
  }
}

function make$6(c) {
  if (c.TAG === "Selector") {
    return c._0;
  } else {
    return c._0 + `:` + strategyToString(c._1);
  }
}

function make$7(vals) {
  switch (vals.TAG) {
    case "Json" :
      return JSON.stringify(vals._0);
    case "JsonUnsafe" :
      return vals._0;
    case "RawJavaScript" :
      return `js:` + vals._0;
  }
}

let Vals = {
  make: make$7
};

function make$8(d) {
  if (typeof d !== "object") {
    return "*";
  } else {
    return d._0.map(a => a).join(" ");
  }
}

let Disinherit = {
  make: make$8
};

let Sync = {
  make: make$6
};

exports.Swap = Swap;
exports.Target = Target;
exports.Params = Params;
exports.Encoding = Encoding;
exports.Indicator = Indicator;
exports.Headers = Headers;
exports.Sync = Sync;
exports.Vals = Vals;
exports.Disinherit = Disinherit;
/* No side effect */
