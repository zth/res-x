// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Stdlib = require("@rescript/runtime/lib/js/Stdlib.js");
let Stdlib_Int = require("@rescript/runtime/lib/js/Stdlib_Int.js");
let Stdlib_Array = require("@rescript/runtime/lib/js/Stdlib_Array.js");
let Stdlib_Float = require("@rescript/runtime/lib/js/Stdlib_Float.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");
let Primitive_option = require("@rescript/runtime/lib/js/Primitive_option.js");

function getOrRaise(opt, name, expectedType, message) {
  if (opt !== undefined) {
    return Primitive_option.valFromOption(opt);
  } else {
    return Stdlib.panic(message !== undefined ? message : `Expected "` + name + `" to be ` + expectedType + `, but got something else.`);
  }
}

function getString(t, name, allowEmptyStringOpt) {
  let allowEmptyString = allowEmptyStringOpt !== undefined ? allowEmptyStringOpt : false;
  let s = t.get(name);
  if (typeof s !== "string") {
    return;
  } else if (s === "" && allowEmptyString) {
    return "";
  } else {
    return s;
  }
}

function getInt(t, name) {
  return Stdlib_Option.flatMap(getString(t, name, undefined), s => Stdlib_Int.fromString(s, undefined));
}

function getFloat(t, name) {
  return Stdlib_Option.flatMap(getString(t, name, undefined), Stdlib_Float.fromString);
}

function getBool(t, name) {
  let match = t.get(name);
  if (match === null) {
    return;
  }
  if (typeof match !== "string") {
    return;
  }
  switch (match) {
    case "false" :
    case "off" :
      return false;
    case "on" :
    case "true" :
      return true;
    default:
      return;
  }
}

function getStringArray(t, name) {
  return Stdlib_Array.keepSome(t.getAll(name).map(v => {
    if (typeof v === "string") {
      return v;
    }
  }));
}

function getIntArray(t, name) {
  return Stdlib_Array.keepSome(t.getAll(name).map(v => {
    if (typeof v === "string") {
      return Stdlib_Int.fromString(v, undefined);
    }
  }));
}

function getFloatArray(t, name) {
  return Stdlib_Array.keepSome(t.getAll(name).map(v => {
    if (typeof v === "string") {
      return Stdlib_Float.fromString(v);
    }
  }));
}

function getBoolArray(t, name) {
  return Stdlib_Array.keepSome(t.getAll(name).map(v => {
    if (typeof v !== "string") {
      return;
    }
    switch (v) {
      case "false" :
        return false;
      case "true" :
        return true;
      default:
        return;
    }
  }));
}

function getCustom(t, name, decoder) {
  return decoder(t.get(name));
}

function expectCustom(t, name, decoder) {
  let message = decoder(t.get(name));
  if (message.TAG === "Ok") {
    return message._0;
  } else {
    return Stdlib.panic(message._0);
  }
}

function expectString(t, name, message) {
  return getOrRaise(getString(t, name, undefined), name, "string", message);
}

function expectInt(t, name, message) {
  return getOrRaise(getInt(t, name), name, "int", message);
}

function expectFloat(t, name, message) {
  return getOrRaise(getFloat(t, name), name, "float", message);
}

function expectBool(t, name, message) {
  return getOrRaise(getBool(t, name), name, "bool", message);
}

function expectCheckbox(t, name) {
  return expectCustom(t, name, res => {
    if (res !== "on") {
      return {
        TAG: "Ok",
        _0: false
      };
    } else {
      return {
        TAG: "Ok",
        _0: true
      };
    }
  });
}

function expectDate(t, name) {
  return expectCustom(t, name, res => {
    if (res === null) {
      return {
        TAG: "Error",
        _0: "Invalid date."
      };
    }
    if (typeof res !== "string") {
      return {
        TAG: "Error",
        _0: "Invalid date."
      };
    }
    let date = new Date(res);
    if (Number.isNaN(date.getTime())) {
      return {
        TAG: "Error",
        _0: "Invalid date."
      };
    } else {
      return {
        TAG: "Ok",
        _0: date
      };
    }
  });
}

exports.getOrRaise = getOrRaise;
exports.getString = getString;
exports.getInt = getInt;
exports.getFloat = getFloat;
exports.getBool = getBool;
exports.getStringArray = getStringArray;
exports.getIntArray = getIntArray;
exports.getFloatArray = getFloatArray;
exports.getBoolArray = getBoolArray;
exports.getCustom = getCustom;
exports.expectCustom = expectCustom;
exports.expectString = expectString;
exports.expectInt = expectInt;
exports.expectFloat = expectFloat;
exports.expectBool = expectBool;
exports.expectCheckbox = expectCheckbox;
exports.expectDate = expectDate;
/* No side effect */
