// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Core__Math = require("@rescript/core/src/Core__Math.js");
var RescriptCore = require("@rescript/core/src/RescriptCore.js");
var Handlers$ResX = require("../src/Handlers.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var ResX__ReactDOM$ResX = require("../src/ResX__ReactDOM.js");

var handler = Handlers$ResX.make(async function (_req) {
      
    });

var Handler = {
  handler: handler
};

var currentPortsUsed = new Set();

function getPort() {
  var port;
  while(port === undefined) {
    var assignedPort = Core__Math.Int.random(40000, 50000);
    if (!currentPortsUsed.has(assignedPort)) {
      currentPortsUsed.add(assignedPort);
      port = assignedPort;
    }
    
  };
  var port$1 = port;
  if (port$1 !== undefined) {
    return [
            port$1,
            (function () {
                currentPortsUsed.delete(port$1);
              })
          ];
  } else {
    return [
            -1,
            (function () {
                
              })
          ];
  }
}

function TestUtils$Html(props) {
  return ResX__ReactDOM$ResX.jsxs("html", {
              children: [
                ResX__ReactDOM$ResX.jsx("head", {}),
                ResX__ReactDOM$ResX.jsx("body", {
                      children: props.children
                    })
              ]
            });
}

var Html = {
  make: TestUtils$Html
};

async function getResponse(getContent, onBeforeSendResponse) {
  var match = getPort();
  var port = match[0];
  var server = Bun.serve({
        development: true,
        port: port,
        fetch: (async function (request, _server) {
            return await Handlers$ResX.handleRequest(handler, {
                        request: request,
                        render: (async function (renderConfig) {
                            return getContent(renderConfig);
                          }),
                        setupHeaders: (function () {
                            return new Headers([[
                                          "Content-Type",
                                          "text/html"
                                        ]]);
                          }),
                        onBeforeSendResponse: onBeforeSendResponse
                      });
          })
      });
  var res;
  var exit = 0;
  var res$1;
  try {
    res$1 = await fetch("http://localhost:" + port.toString() + "/", undefined);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Js_exn.$$Error) {
      res = {
        TAG: "Error",
        _0: "Failed to fetch."
      };
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    res = {
      TAG: "Ok",
      _0: res$1
    };
  }
  server.stop(true);
  match[1]();
  if (res.TAG === "Ok") {
    return res._0;
  } else {
    return RescriptCore.panic(res._0);
  }
}

async function getContentInBody(getContent) {
  var content = await getResponse(getContent, undefined);
  return await content.text();
}

var React;

var ReactDOM;

var portsBase = 40000;

exports.React = React;
exports.ReactDOM = ReactDOM;
exports.Handler = Handler;
exports.currentPortsUsed = currentPortsUsed;
exports.portsBase = portsBase;
exports.getPort = getPort;
exports.Html = Html;
exports.getResponse = getResponse;
exports.getContentInBody = getContentInBody;
/* handler Not a pure module */
