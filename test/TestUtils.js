// Generated by ReScript, PLEASE EDIT WITH CARE

let Stdlib = require("@rescript/runtime/lib/js/Stdlib.js");
let Hjsx$ResX = require("../src/Hjsx.js");
let Stdlib_Exn = require("@rescript/runtime/lib/js/Stdlib_Exn.js");
let Stdlib_Math = require("@rescript/runtime/lib/js/Stdlib_Math.js");
let Handlers$ResX = require("../src/Handlers.js");
let Primitive_exceptions = require("@rescript/runtime/lib/js/Primitive_exceptions.js");

let testHandler = Handlers$ResX.make(async _req => ({
  shouldAppendToHead: false
}), undefined);

let Handler = {
  testHandler: testHandler
};

let currentPortsUsed = new Set();

function getPort() {
  let port;
  while (port === undefined) {
    let assignedPort = Stdlib_Math.Int.random(40000, 50000);
    if (!currentPortsUsed.has(assignedPort)) {
      currentPortsUsed.add(assignedPort);
      port = assignedPort;
    }
  };
  let port$1 = port;
  if (port$1 !== undefined) {
    return [
      port$1,
      () => {
        currentPortsUsed.delete(port$1);
      }
    ];
  } else {
    return [
      -1,
      () => {}
    ];
  }
}

function TestUtils$Html(props) {
  return Hjsx$ResX.Elements.jsxs("html", {
    children: [
      Hjsx$ResX.Elements.jsx("head", {}),
      Hjsx$ResX.Elements.jsx("body", {
        children: props.children
      })
    ]
  });
}

let Html = {
  make: TestUtils$Html
};

async function getResponse(methodOpt, getContent, onBeforeSendResponse, onBeforeBuildResponse, onAfterBuildResponse, urlOpt) {
  let method = methodOpt !== undefined ? methodOpt : "GET";
  let url = urlOpt !== undefined ? urlOpt : "/";
  let match = getPort();
  let port = match[0];
  let server = Bun.serve({
    development: true,
    port: port,
    fetch: async (request, _server) => await Handlers$ResX.handleRequest(testHandler, {
      request: request,
      render: async renderConfig => {
        if (getContent !== undefined) {
          return getContent(renderConfig);
        } else {
          return null;
        }
      },
      setupHeaders: () => new Headers([[
          "Content-Type",
          "text/html"
        ]]),
      onBeforeSendResponse: onBeforeSendResponse,
      onBeforeBuildResponse: onBeforeBuildResponse,
      onAfterBuildResponse: onAfterBuildResponse
    })
  });
  let res;
  let exit = 0;
  let res$1;
  try {
    res$1 = await fetch(`http://localhost:` + port.toString() + url, {
      method: method
    });
    exit = 1;
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib_Exn.$$Error) {
      res = {
        TAG: "Error",
        _0: "Failed to fetch."
      };
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    res = {
      TAG: "Ok",
      _0: res$1
    };
  }
  server.stop(true);
  match[1]();
  if (res.TAG === "Ok") {
    return res._0;
  } else {
    return Stdlib.panic(res._0);
  }
}

async function getContentInBody(getContent) {
  let content = await getResponse(undefined, getContent, undefined, undefined, undefined, undefined);
  return await content.text();
}

async function getResponseWithInit(urlOpt, init) {
  let url = urlOpt !== undefined ? urlOpt : "/";
  let match = getPort();
  let port = match[0];
  let server = Bun.serve({
    development: true,
    port: port,
    fetch: async (request, _server) => await Handlers$ResX.handleRequest(testHandler, {
      request: request,
      render: async _renderConfig => null,
      setupHeaders: () => new Headers([[
          "Content-Type",
          "text/html"
        ]])
    })
  });
  let res;
  let exit = 0;
  let res$1;
  try {
    res$1 = await fetch(`http://localhost:` + port.toString() + url, init);
    exit = 1;
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib_Exn.$$Error) {
      res = {
        TAG: "Error",
        _0: "Failed to fetch."
      };
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    res = {
      TAG: "Ok",
      _0: res$1
    };
  }
  server.stop(true);
  match[1]();
  if (res.TAG === "Ok") {
    return res._0;
  } else {
    return Stdlib.panic(res._0);
  }
}

let portsBase = 40000;

exports.Handler = Handler;
exports.currentPortsUsed = currentPortsUsed;
exports.portsBase = portsBase;
exports.getPort = getPort;
exports.Html = Html;
exports.getResponse = getResponse;
exports.getContentInBody = getContentInBody;
exports.getResponseWithInit = getResponseWithInit;
/* testHandler Not a pure module */
