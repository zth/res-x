// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Stdlib = require("@rescript/runtime/lib/js/Stdlib.js");
let Buntest = require("bun:test");
let Hjsx$ResX = require("../src/Hjsx.js");
let Handlers$ResX = require("../src/Handlers.js");
let TestUtils$ResX = require("./TestUtils.js");
let Primitive_option = require("@rescript/runtime/lib/js/Primitive_option.js");
let RenderInHead$ResX = require("../src/RenderInHead.js");
let ErrorBoundary$ResX = require("../src/ErrorBoundary.js");
let RequestController$ResX = require("../src/RequestController.js");
let RenderBeforeBodyEnd$ResX = require("../src/RenderBeforeBodyEnd.js");

Buntest.describe("rendering", () => {
  Buntest.describe("render before body end", () => {
    Buntest.test("render body-end content", async () => {
      let text = await TestUtils$ResX.getContentInBody(renderConfig => Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
        children: Hjsx$ResX.jsx(RenderBeforeBodyEnd$ResX.make, {
          children: Hjsx$ResX.Elements.jsx("script", {
            src: "/test.js"
          }),
          requestController: renderConfig.requestController
        })
      }));
      Buntest.expect(text).toBe(`<!DOCTYPE html><html><head></head><body><script src="/test.js"></script></body></html>`);
    });
  });
  Buntest.describe("render in head", () => {
    let make = async param => {
      let context = Handlers$ResX.useContext(TestUtils$ResX.Handler.testHandler);
      return Hjsx$ResX.jsx(RenderInHead$ResX.make, {
        children: Hjsx$ResX.Elements.jsx("meta", {
          content: "test",
          name: "test"
        }),
        requestController: context.requestController
      });
    };
    let Rendering$dottest = make;
    Buntest.test("render in head with async component", async () => {
      let text = await TestUtils$ResX.getContentInBody(_renderConfig => Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
        children: Hjsx$ResX.jsx(Rendering$dottest, {})
      }));
      Buntest.expect(text).toBe(`<!DOCTYPE html><html><head><meta content="test" name="test"/></head><body></body></html>`);
    });
    Buntest.test("render in head", async () => {
      let text = await TestUtils$ResX.getContentInBody(renderConfig => Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
        children: Hjsx$ResX.jsx(RenderInHead$ResX.make, {
          children: Hjsx$ResX.Elements.jsx("meta", {
            content: "test",
            name: "test"
          }),
          requestController: renderConfig.requestController
        })
      }));
      Buntest.expect(text).toBe(`<!DOCTYPE html><html><head><meta content="test" name="test"/></head><body></body></html>`);
    });
  });
  Buntest.describe("DOCTYPE", () => {
    Buntest.test("change DOCTYPE", async () => {
      let text = await TestUtils$ResX.getContentInBody(renderConfig => {
        RequestController$ResX.setDocHeader(renderConfig.requestController, `<?xml version="1.0" encoding="UTF-8"?>`);
        return null;
      });
      Buntest.expect(text).toBe(`<?xml version="1.0" encoding="UTF-8"?>`);
    });
    Buntest.test("remove DOCTYPE", async () => {
      let text = await TestUtils$ResX.getContentInBody(renderConfig => {
        RequestController$ResX.setDocHeader(renderConfig.requestController, undefined);
        return Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
          children: Hjsx$ResX.Elements.jsx("div", {})
        });
      });
      Buntest.expect(text).toBe(`<html><head></head><body><div></div></body></html>`);
    });
  });
  Buntest.describe("Security", () => {
    Buntest.test("title segments are escaped", async () => {
      let text = await TestUtils$ResX.getContentInBody(renderConfig => {
        RequestController$ResX.appendTitleSegment(renderConfig.requestController, "</title></head>");
        return Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
          children: Hjsx$ResX.Elements.jsx("div", {})
        });
      });
      Buntest.expect(text).toBe(`<!DOCTYPE html><html><head><title>&lt;/title&gt;&lt;/head&gt;</title></head><body><div></div></body></html>`);
    });
  });
  Buntest.describe("hooks", () => {
    Buntest.test("onAfterBuildResponse can append before body end", async () => {
      let response = await TestUtils$ResX.getResponse(undefined, _renderConfig => Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
        children: Hjsx$ResX.Elements.jsx("div", {
          children: "Hi!"
        })
      }), undefined, undefined, async config => RequestController$ResX.appendBeforeBodyEnd(config.requestController, Hjsx$ResX.Elements.jsx("script", {
        src: "/after.js"
      })), undefined);
      let text = await response.text();
      Buntest.expect(text).toBe(`<!DOCTYPE html><html><head></head><body><div>Hi!</div><script src="/after.js"></script></body></html>`);
    });
    Buntest.describe("onBeforeBuildResponse can set appended header content", () => {
      let getResponseWithShouldAppendToHeadValue = shouldAppendToHead => TestUtils$ResX.getResponse(undefined, param => {
        param.context.shouldAppendToHead = shouldAppendToHead;
        return Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
          children: Hjsx$ResX.Elements.jsx("div", {
            children: "Hi!"
          })
        });
      }, undefined, async config => {
        if (config.context.shouldAppendToHead) {
          return RequestController$ResX.appendToHead(config.requestController, Hjsx$ResX.Elements.jsx("meta", {
            content: "test",
            name: "test"
          }));
        }
      }, undefined, undefined);
      Buntest.test("can read context to control appending to head - should append", async () => {
        let response = await getResponseWithShouldAppendToHeadValue(true);
        let text = await response.text();
        Buntest.expect(text).toBe(`<!DOCTYPE html><html><head><meta content="test" name="test"/></head><body><div>Hi!</div></body></html>`);
      });
      Buntest.test("can read context to control appending to head - should not append", async () => {
        let response = await getResponseWithShouldAppendToHeadValue(false);
        let text = await response.text();
        Buntest.expect(text).toBe(`<!DOCTYPE html><html><head></head><body><div>Hi!</div></body></html>`);
      });
    });
    Buntest.test("onBeforeSendResponse change status", async () => {
      let response = await TestUtils$ResX.getResponse(undefined, _renderConfig => Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
        children: Hjsx$ResX.Elements.jsx("div", {
          children: "Hi!"
        })
      }), async config => new Response(await config.response.text(), {
        status: 400,
        headers: config.response.headers.toJSON()
      }), undefined, undefined, undefined);
      let status = response.status;
      let text = await response.text();
      Buntest.expect(status).toBe(400);
      Buntest.expect(text).toBe(`<!DOCTYPE html><html><head></head><body><div>Hi!</div></body></html>`);
    });
    Buntest.test("onBeforeSendResponse set header", async () => {
      let response = await TestUtils$ResX.getResponse(undefined, _renderConfig => Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
        children: Hjsx$ResX.Elements.jsx("div", {
          children: "Hi!"
        })
      }), async config => {
        config.response.headers.set("x-user-id", "1");
        return config.response;
      }, undefined, undefined, undefined);
      let userIdHeader = response.headers.get("x-user-id");
      Buntest.expect((userIdHeader == null) ? undefined : Primitive_option.some(userIdHeader)).toBe("1");
    });
  });
  Buntest.test("escaped and raw content", async () => {
    let text = await TestUtils$ResX.getContentInBody(_renderConfig => Hjsx$ResX.Elements.jsxs("div", {
      children: [
        "<div>Hi!</div>",
        Hjsx$ResX.dangerouslyOutputUnescapedContent("<span>Hi!</span>")
      ]
    }));
    Buntest.expect(text).toBe(`<!DOCTYPE html><div>&lt;div&gt;Hi!&lt;/div&gt;<span>Hi!</span></div>`);
  });
  Buntest.describe("CSV export", () => {
    Buntest.test("CSV with content that would be HTML escaped", async () => {
      let response = await TestUtils$ResX.getResponse(undefined, renderConfig => {
        RequestController$ResX.setDocHeader(renderConfig.requestController, undefined);
        renderConfig.headers.set("Content-Type", "text/csv; charset=UTF-8");
        renderConfig.headers.set("Content-Disposition", "attachment; filename=\"test.csv\"");
        return Hjsx$ResX.dangerouslyOutputUnescapedContent(`Name,Description,Tags
"John & Jane Doe","<Special> characters & symbols","tag1,tag2"
"Bob's Company","Uses "quotes" & <brackets>","web,tech"
"Test Corp","R&D Department","research&development"`);
      }, undefined, undefined, undefined, undefined);
      let contentType = response.headers.get("Content-Type");
      let contentDisposition = response.headers.get("Content-Disposition");
      let text = await response.text();
      Buntest.expect((contentType == null) ? undefined : Primitive_option.some(contentType)).toBe("text/csv; charset=UTF-8");
      Buntest.expect((contentDisposition == null) ? undefined : Primitive_option.some(contentDisposition)).toBe("attachment; filename=\"test.csv\"");
      Buntest.expect(text).toBe(`Name,Description,Tags
"John & Jane Doe","<Special> characters & symbols","tag1,tag2"
"Bob's Company","Uses "quotes" & <brackets>","web,tech"
"Test Corp","R&D Department","research&development"`);
    });
    Buntest.test("demonstrates difference with HTML escaping", async () => {
      let text = await TestUtils$ResX.getContentInBody(_renderConfig => Hjsx$ResX.Elements.jsx("div", {
        children: `"Company","Description"
"Bob's Corp","<Special> characters & symbols"`
      }));
      Buntest.expect(text).toBe(`<!DOCTYPE html><div>&quot;Company&quot;,&quot;Description&quot;
&quot;Bob&#x27;s Corp&quot;,&quot;&lt;Special&gt; characters &amp; symbols&quot;</div>`);
    });
  });
});

function fnThatErrors() {
  Stdlib.panic("panic!");
  return "hello";
}

function Rendering$dottest$PanicComponent(props) {
  return Hjsx$ResX.Elements.jsx("div", {
    children: (Stdlib.panic("panic!"), "hello")
  });
}

let PanicComponent = {
  fnThatErrors: fnThatErrors,
  make: Rendering$dottest$PanicComponent
};

Buntest.describe("error boundaries", () => {
  Buntest.test("error boundary catches panic", async () => {
    let text = await TestUtils$ResX.getContentInBody(_renderConfig => Hjsx$ResX.jsx(TestUtils$ResX.Html.make, {
      children: Hjsx$ResX.jsx(ErrorBoundary$ResX.make, {
        children: Hjsx$ResX.jsx(Rendering$dottest$PanicComponent, {}),
        renderError: param => Hjsx$ResX.Elements.jsx("div", {
          children: "Error!"
        })
      })
    }));
    Buntest.expect(text).toBe(`<!DOCTYPE html><html><head></head><body><div>Error!</div></body></html>`);
  });
});

exports.PanicComponent = PanicComponent;
/*  Not a pure module */
